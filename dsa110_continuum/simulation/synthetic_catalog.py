"""
Generate synthetic catalog entries matching synthetic source positions.

This module creates catalog databases (NVSS, FIRST, etc.) with entries that match
synthetic sources generated by make_synthetic_uvh5.py. This enables full testing
of the CrossMatchStage pipeline stage.
"""

from __future__ import annotations

import sqlite3
from pathlib import Path

import numpy as np


def create_synthetic_catalog_db(
    output_path: Path,
    source_positions: list[tuple[float, float, float]],
    catalog_type: str = "nvss",
    dec_strip: float | None = None,
    add_noise: bool = True,
    position_noise_arcsec: float = 0.1,
    flux_noise_fraction: float = 0.05,
    rng: np.random.Generator | None = None,
) -> Path:
    """Create a synthetic catalog database matching synthetic source positions.

        This creates a SQLite database in the same format as real catalog databases
        (NVSS, FIRST, etc.) with entries that match synthetic source positions.
        This enables full testing of the CrossMatchStage.

    Parameters
    ----------
    output_path : Path
        Path to output SQLite database file
    source_positions : list of tuple of float
        List of (ra_deg, dec_deg, flux_jy) tuples for each source
    catalog_type : str, optional
        Catalog type ("nvss", "first", "rax", etc.) (default is "nvss")
    dec_strip : float or None, optional
        Declination strip (auto-detected from sources if None) (default is None)
    add_noise : bool, optional
        Add small random noise to positions/fluxes (default is True)
    position_noise_arcsec : float, optional
        Position noise in arcseconds (default is 0.1)
    flux_noise_fraction : float, optional
        Flux noise as fraction of flux (default is 0.05)
    rng : np.random.Generator or None, optional
        Random number generator for reproducibility (default is None)

    Returns
    -------
        Path
        Path to created catalog database.

    Examples
    --------
        >>> from pathlib import Path
        >>> import numpy as np
        >>>
        >>> # Generate synthetic sources
        >>> sources = [
        ...     (180.0, 35.0, 0.1),  # RA, Dec, flux in Jy
        ...     (180.1, 35.0, 0.05),
        ... ]
        >>>
        >>> # Create matching catalog
        >>> db_path = create_synthetic_catalog_db(
        ...     output_path=Path("test_nvss_dec35.0.sqlite3"),
        ...     source_positions=sources,
        ...     catalog_type="nvss",
        ...     dec_strip=35.0,
        ... )
        >>>
        >>> # Use in pipeline testing
        >>> import os
        >>> os.environ["NVSS_CATALOG"] = str(db_path)
    """
    if rng is None:
        rng = np.random.default_rng()

    # Auto-detect dec_strip from sources if not provided
    if dec_strip is None and source_positions:
        dec_center = np.mean([pos[1] for pos in source_positions])
        dec_strip = round(float(dec_center), 1)

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Create database
    conn = sqlite3.connect(str(output_path))
    cursor = conn.cursor()

    # Create sources table (NVSS/FIRST/RAX format)
    if catalog_type.lower() == "first":
        # FIRST includes source size information
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS sources (
                source_id INTEGER PRIMARY KEY AUTOINCREMENT,
                ra_deg REAL NOT NULL,
                dec_deg REAL NOT NULL,
                flux_mjy REAL,
                maj_arcsec REAL,
                min_arcsec REAL,
                pa_deg REAL,
                UNIQUE(ra_deg, dec_deg)
            )
        """
        )
    else:
        # NVSS, RAX, VLASS format (flux only)
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS sources (
                source_id INTEGER PRIMARY KEY AUTOINCREMENT,
                ra_deg REAL NOT NULL,
                dec_deg REAL NOT NULL,
                flux_mjy REAL,
                UNIQUE(ra_deg, dec_deg)
            )
        """
        )

    # Create spatial indices
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_radec ON sources(ra_deg, dec_deg)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_dec ON sources(dec_deg)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_flux ON sources(flux_mjy)")

    # Create metadata table
    cursor.execute(
        """
        CREATE TABLE IF NOT EXISTS meta (
            key TEXT PRIMARY KEY,
            value TEXT
        )
    """
    )

    # Insert metadata
    if dec_strip is not None:
        dec_min = min([pos[1] for pos in source_positions]) if source_positions else dec_strip - 0.5
        dec_max = max([pos[1] for pos in source_positions]) if source_positions else dec_strip + 0.5
        dec_center = (dec_min + dec_max) / 2.0

        cursor.execute(
            "INSERT OR REPLACE INTO meta(key, value) VALUES('dec_center', ?)",
            (str(dec_center),),
        )
        cursor.execute(
            "INSERT OR REPLACE INTO meta(key, value) VALUES('dec_min', ?)",
            (str(dec_min),),
        )
        cursor.execute(
            "INSERT OR REPLACE INTO meta(key, value) VALUES('dec_max', ?)",
            (str(dec_max),),
        )
        cursor.execute(
            "INSERT OR REPLACE INTO meta(key, value) VALUES('catalog_type', ?)",
            (catalog_type.lower(),),
        )
        cursor.execute(
            "INSERT OR REPLACE INTO meta(key, value) VALUES('synthetic', ?)",
            ("true",),
        )

    # Insert sources
    for ra_deg, dec_deg, flux_jy in source_positions:
        # Add realistic catalog errors (small position/flux uncertainties)
        if add_noise:
            # Position noise (arcsec -> degrees)
            ra_noise_deg = rng.normal(0.0, position_noise_arcsec / 3600.0)
            dec_noise_deg = rng.normal(0.0, position_noise_arcsec / 3600.0)
            ra_catalog = ra_deg + ra_noise_deg / np.cos(np.deg2rad(dec_deg))
            dec_catalog = dec_deg + dec_noise_deg

            # Flux noise (fractional)
            flux_noise = rng.normal(1.0, flux_noise_fraction)
            flux_catalog_jy = flux_jy * flux_noise
        else:
            ra_catalog = ra_deg
            dec_catalog = dec_deg
            flux_catalog_jy = flux_jy

        # Convert flux from Jy to mJy
        flux_mjy = flux_catalog_jy * 1000.0

        if catalog_type.lower() == "first":
            # FIRST includes source size (assume point source for synthetic)
            cursor.execute(
                """
                INSERT OR REPLACE INTO sources
                (ra_deg, dec_deg, flux_mjy, maj_arcsec, min_arcsec, pa_deg)
                VALUES (?, ?, ?, ?, ?, ?)
            """,
                (ra_catalog, dec_catalog, flux_mjy, 0.0, 0.0, 0.0),
            )
        else:
            # NVSS, RAX, VLASS format
            cursor.execute(
                """
                INSERT OR REPLACE INTO sources (ra_deg, dec_deg, flux_mjy)
                VALUES (?, ?, ?)
            """,
                (ra_catalog, dec_catalog, flux_mjy),
            )

    conn.commit()
    conn.close()

    return output_path


def create_synthetic_catalog_from_uvh5(
    uvh5_path: Path,
    catalog_output_path: Path,
    catalog_type: str = "nvss",
    add_noise: bool = True,
    rng: np.random.Generator | None = None,
) -> Path:
    """Create synthetic catalog database from UVH5 file metadata.

    Extracts source positions from UVH5 file metadata (if available) and creates
    a matching catalog database. This is useful when synthetic UVH5 files contain
    source information in their metadata.

    Parameters
    ----------
    uvh5_path :
        Path to synthetic UVH5 file
    catalog_output_path :
        Path to output catalog database
    catalog_type :
        Catalog type ("nvss", "first", etc.)
    add_noise :
        Add realistic catalog errors
    rng :
        Random number generator

    Returns
    -------
        Path to created catalog database

    """
    try:
        import pyuvdata

        uv = pyuvdata.UVData()
        uv.read(str(uvh5_path))

        # Extract source positions from metadata
        # Check if synthetic source info is in extra_keywords
        source_positions = []

        if "synthetic_source_ra_deg" in uv.extra_keywords:
            # Single source
            ra = float(uv.extra_keywords["synthetic_source_ra_deg"])
            dec = float(uv.extra_keywords["synthetic_source_dec_deg"])
            flux = float(uv.extra_keywords.get("synthetic_source_flux_jy", 0.1))
            source_positions = [(ra, dec, flux)]
        elif "synthetic_sources" in uv.extra_keywords:
            # Multiple sources (JSON string)
            import json

            sources_json = uv.extra_keywords["synthetic_sources"]
            sources_data = json.loads(sources_json)
            source_positions = [(s["ra_deg"], s["dec_deg"], s["flux_jy"]) for s in sources_data]

        if not source_positions:
            # Fallback: use phase center as source position
            ra = uv.phase_center_ra_degrees
            dec = uv.phase_center_dec_degrees
            flux = 0.1  # Default flux
            source_positions = [(ra, dec, flux)]

        # Get dec_strip from phase center
        dec_strip = round(float(uv.phase_center_dec_degrees), 1)

        return create_synthetic_catalog_db(
            output_path=catalog_output_path,
            source_positions=source_positions,
            catalog_type=catalog_type,
            dec_strip=dec_strip,
            add_noise=add_noise,
            rng=rng,
        )

    except Exception as e:
        raise RuntimeError(f"Failed to create catalog from UVH5 file {uvh5_path}: {e}") from e
